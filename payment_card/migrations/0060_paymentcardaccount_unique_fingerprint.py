# Generated by Django 4.2.6 on 2023-11-21 16:22
from collections import defaultdict
from typing import TYPE_CHECKING, cast

from django.db import migrations, models, transaction
from django.db.models import Count

if TYPE_CHECKING:
    from payment_card.models import PaymentCardAccount as PaymentCardAccountType
    from scheme.models import SchemeAccount as SchemeAccountType
    from ubiquity.models import PaymentCardSchemeEntry as PaymentCardSchemeEntryType


def _handle_same_mcard(pll: "PaymentCardSchemeEntryType", correct_pll: "PaymentCardSchemeEntryType") -> None:
    already_linked_users = [plluser.user_id for plluser in correct_pll.plluserassociation_set.all()]

    for user_pll in pll.plluserassociation_set.all():
        if user_pll.user_id in already_linked_users:
            user_pll.delete()
        else:
            user_pll.pll_id = correct_pll.id
            user_pll.save(update_fields=["pll_id"])
            already_linked_users.append(user_pll.user_id)


def _handle_duplicated_mcard(
    pll: "PaymentCardSchemeEntryType", correct_scheme_account_id: int, correct_pll: "PaymentCardSchemeEntryType"
) -> None:
    pll.scheme_account.is_deleted = True
    pll.scheme_account.save(update_fields=["is_deleted"])

    existing_users = [plluser.user_id for plluser in correct_pll.plluserassociation_set.all()]

    for sae in pll.scheme_account.schemeaccountentry_set.all():
        sae.scheme_account_id = correct_scheme_account_id
        sae.save(update_fields=["scheme_account_id"])

    for user_pll in pll.plluserassociation_set.all():
        if user_pll.user_id in existing_users:
            user_pll.delete()
        else:
            user_pll.pll_id = correct_pll.id
            user_pll.save(update_fields=["pll_id"])
            existing_users.append(user_pll.user_id)


def _handle_links_to_users(
    pcard: "PaymentCardAccountType", correct_pcard_id: int, existing_linked_users: list[int]
) -> None:
    for entry in pcard.paymentcardaccountentry_set.all():
        if entry.user_id in existing_linked_users:
            entry.delete()
        else:
            entry.payment_card_account_id = correct_pcard_id
            entry.save(update_fields=["payment_card_account_id"])
            existing_linked_users.append(entry.user_id)


def _handle_remaining_pcards(oldest_pcard: "PaymentCardAccountType", remaining_pcards: list["PaymentCardAccountType"]):
    def get_main_answer(scheme_account: "SchemeAccountType") -> str:
        return scheme_account.card_number or scheme_account.barcode or scheme_account.alt_main_answer

    existing_main_answers: dict[str, int] = {}
    existing_plls: dict[int, "PaymentCardSchemeEntryType"] = {}
    for pll in oldest_pcard.paymentcardschemeentry_set.all():
        existing_main_answers[get_main_answer(pll.scheme_account)] = pll.scheme_account_id
        existing_plls[pll.scheme_account_id] = pll

    existing_linked_users = [entry.user_id for entry in oldest_pcard.paymentcardaccountentry_set.all()]

    for pcard in remaining_pcards:
        # transfer any user links
        with transaction.atomic():
            _handle_links_to_users(pcard, oldest_pcard.id, existing_linked_users)

        with transaction.atomic():
            for pll in pcard.paymentcardschemeentry_set.all():
                pll_migrated = False

                if pll.scheme_account_id not in existing_plls:
                    if (main_answer := get_main_answer(pll.scheme_account)) not in existing_main_answers:
                        pll.payment_card_account_id = oldest_pcard.id
                        pll.save(update_fields=["payment_card_account_id"])
                        existing_main_answers[main_answer] = pll.scheme_account_id
                        existing_plls[pll.scheme_account_id] = pll
                        pll_migrated = True
                    else:
                        correct_scheme_account_id = existing_main_answers[main_answer]
                        _handle_duplicated_mcard(
                            pll, correct_scheme_account_id, existing_plls[correct_scheme_account_id]
                        )

                else:
                    _handle_same_mcard(pll, existing_plls[pll.scheme_account_id])

                if not pll_migrated:
                    pll.delete()

        # soft delete newer cards
        pcard.is_deleted = True
        pcard.save(update_fields=["is_deleted"])


def remove_duplicates(apps, schema_editor):
    PaymentCardAccount = cast("PaymentCardAccountType", apps.get_model("payment_card", "PaymentCardAccount"))

    # Query to find fingerprints that have been duplicated for active accounts
    dupe_fingerprints = (
        PaymentCardAccount.all_objects.filter(is_deleted=False)
        .values("fingerprint")  # this is used to tell .annotate what to group by on
        .annotate(fingerprint_count=Count("fingerprint"))
        .filter(fingerprint_count__gt=1)
        .values_list("fingerprint", flat=True)  # this is used to tell the orm what to select
    )

    # Find all accounts containing the duplicate fingerprints
    dupe_accounts = (
        PaymentCardAccount.all_objects.filter(fingerprint__in=dupe_fingerprints)
        .prefetch_related("paymentcardaccountentry_set", "paymentcardschemeentry_set", "scheme_account_set")
        .order_by()
    )

    # group payment cards id by fingerprint
    dupe_key_to_acc_map: dict[str, list["PaymentCardAccountType"]] = defaultdict(list)
    for acc in dupe_accounts:
        dupe_key_to_acc_map[acc.fingerprint].append(acc)

    for pcards in dupe_key_to_acc_map.values():
        pcards.sort(key=lambda card: card.created)
        oldest_pcard, *remaining_pcards = pcards

        _handle_remaining_pcards(oldest_pcard, remaining_pcards)

        latest_pcard = remaining_pcards[-1]
        expiry_year = latest_pcard.expiry_year
        expiry_month = latest_pcard.expiry_month

        # Update old card with latest expiry date
        if oldest_pcard.expiry_year != expiry_year or oldest_pcard.expiry_month != expiry_month:
            oldest_pcard.expiry_month = expiry_month
            oldest_pcard.expiry_year = expiry_year

        oldest_pcard.save()


def reverse(apps, schema_editor):
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("payment_card", "0059_vopmerchantgroup_vopmerchantgroup_unique_default"),
    ]

    operations = [
        migrations.RunPython(code=remove_duplicates, reverse_code=reverse),
        migrations.AddConstraint(
            model_name="paymentcardaccount",
            constraint=models.UniqueConstraint(
                condition=models.Q(("is_deleted", False)),
                fields=("fingerprint",),
                name="unique_active_fingerprint",
                violation_error_message="An active payment account with this fingerprint already exists",
            ),
        ),
    ]
