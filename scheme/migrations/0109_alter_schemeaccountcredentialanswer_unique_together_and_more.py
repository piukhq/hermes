# Generated by Django 4.0.6 on 2022-07-27 07:32
import itertools
import logging
from time import sleep
from uuid import uuid4

import django.db.models.deletion
from celery import shared_task
from django.conf import settings
from django.db import migrations, models
from django.db.utils import OperationalError
from redis.client import Redis

from scheme.models import SchemeAccount, SchemeAccountCredentialAnswer, SchemeCredentialQuestion
from ubiquity.models import SchemeAccountEntry

TASK_SIZE = 500
MIGRATION_TASK_PREFIX = "hermes-migration-populate-answer-"
r_write = Redis(connection_pool=settings.REDIS_WRITE_API_CACHE_POOL)
r_read = Redis(connection_pool=settings.REDIS_READ_API_CACHE_POOL)


def retry_redis(action, key):
    for x in range(5):
        try:
            redis_key = MIGRATION_TASK_PREFIX + key
            if action == "set":
                r_write.set(redis_key, "True")
            elif action == "delete":
                r_write.delete(redis_key)
            else:
                raise ValueError(f"retry redis func only accepts set or delete, received {action}")
            break
        except Exception as e:
            if x == 4:
                logging.warning(f"redis delete failed 5 times in a row, no more retries, error: {e!r}")
                raise
            logging.warning(f"redis delete broke with exception {e!r}, retrying...")
            sleep(0.2)


def retry_celery(task_id, pks_to_process):
    for x in range(5):
        try:
            populate_answer_task.delay(task_id, pks_to_process)
            break
        except Exception as e:
            if x == 4:
                logging.warning(f"celery delay failed 5 times in a row, no more retries, error: {e!r}")
                raise
            logging.warning(f"celery delay broke with exception {e!r}, retrying...")
            sleep(0.2)


def get_all_answers(scheme_account_ids_to_query):
    for attempt in range(3):
        try:
            all_answers = list(
                SchemeAccountCredentialAnswer.objects.raw(
                    "select * from scheme_schemeaccountcredentialanswer where scheme_account_id IN %s AND scheme_account_entry_id IS NULL",
                    [scheme_account_ids_to_query],
                )
            )
            break
        except OperationalError:
            logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
            if attempt == 2:
                raise
            sleep(0.2)

    return all_answers


def create_all_answers(scheme_account_entries, answer_dict):
    for entry_dict in scheme_account_entries:
        bulk_answers = []
        entry_answers = answer_dict[entry_dict["scheme_account_id"]]
        for answer in entry_answers:
            saca = SchemeAccountCredentialAnswer(
                question_id=answer.question_id,
                answer=answer.answer,
                scheme_account_entry_id=entry_dict["id"],
            )
            bulk_answers.append(saca)

        for attempt in range(3):
            try:
                SchemeAccountCredentialAnswer.objects.bulk_create(bulk_answers)
                break
            except OperationalError:
                logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
                if attempt == 2:
                    raise
                sleep(0.2)


def get_scheme_account_and_merchant_id_questions(answer_dict):
    for attempt in range(3):
        try:
            scheme_account_ids = list(answer_dict.keys())
            scheme_accounts = list(SchemeAccount.objects.filter(id__in=scheme_account_ids))
            answers = answer_dict.values()
            answer_ids = [x.id for x in itertools.chain.from_iterable(answers)]
            merchant_identifier_question_ids = [
                x.id
                for x in SchemeCredentialQuestion.objects.filter(
                    schemeaccountcredentialanswer__id__in=answer_ids, type="merchant_identifier"
                )
            ]
            break
        except OperationalError:
            logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
            if attempt == 2:
                raise
            sleep(0.2)

    return scheme_accounts, merchant_identifier_question_ids


def populate_scheme_account_merchant_identifier(answer_dict):
    scheme_accounts, merchant_identifier_question_ids = get_scheme_account_and_merchant_id_questions(answer_dict)
    records_to_update = []
    for scheme_account in scheme_accounts:
        answers = answer_dict[scheme_account.id]
        for answer in answers:
            if answer.question_id in merchant_identifier_question_ids:
                scheme_account.merchant_identifier = answer.answer
                records_to_update.append(scheme_account)

    for attempt in range(3):
        try:
            SchemeAccount.objects.bulk_update(records_to_update, ["merchant_identifier"], batch_size=100)
            logging.warning(f"Updated {len(records_to_update)} scheme account identifier fields!")
            break
        except OperationalError:
            logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
            if attempt == 2:
                raise
            sleep(0.2)


@shared_task
def populate_answer_task(task_id, pks_to_process):
    try:
        for attempt in range(3):
            try:
                scheme_account_entries = list(
                    SchemeAccountEntry.objects.filter(id__in=pks_to_process).values("id", "scheme_account_id")
                )
                break
            except OperationalError:
                logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
                if attempt == 2:
                    raise
                sleep(0.2)

        scheme_account_ids_to_query = []
        answer_dict = {}
        for entry in scheme_account_entries:
            scheme_account_id = entry["scheme_account_id"]
            scheme_account_ids_to_query.append(scheme_account_id)
            answer_dict[scheme_account_id] = []

        scheme_account_ids_to_query = tuple(scheme_account_ids_to_query)
        all_answers = get_all_answers(scheme_account_ids_to_query)

        for answer in all_answers:
            try:
                answer_dict[answer.scheme_account_id].append(answer)
            except KeyError:
                answer_dict[answer.scheme_account_id] = [answer]

        populate_scheme_account_merchant_identifier(answer_dict)
        create_all_answers(scheme_account_entries, answer_dict)
        retry_redis("delete", task_id)

    except Exception as e:
        logging.warning(
            f"Migration task failed! Migration: '{__file__}', error: {e!r}, "
            f"Migration will stay locked until this is manually pushed through. To do this, run 'populate_answer_task'"
            f"with these arguments: task_id = '{task_id}', pks_to_process = '{pks_to_process}'"
        )
        raise


def wait_for_tasks_to_finish():
    tasks_to_process = True
    while tasks_to_process:
        try:
            tasks_to_process = len(list(r_read.scan_iter(f"{MIGRATION_TASK_PREFIX}*")))
            logging.warning(f"Waiting for async migration to complete, {tasks_to_process} tasks remaining")
            if tasks_to_process:
                sleep(2)
        except Exception as e:
            logging.warning(
                f"Unexpected error happened while checking remaining tasks! I'll keep checking until"
                f"this gets resolved! Error: {e!r}"
            )


def cleanup_answers_table(SchemeAccountCredentialAnswer):
    ## now clean up the answers table - remove all answer without scheme_account_entry
    for attempt in range(3):
        try:
            logging.warning("All async tasks for this migration complete, doing cleanup query before moving on")
            SchemeAccountCredentialAnswer.objects.filter(scheme_account_entry__isnull=True).delete()
            break
        except OperationalError:
            logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
            if attempt == 2:
                raise
            sleep(0.2)


def populate_answers(apps, *args):
    # get the models from the app argument passed through the migration
    SchemeAccountCredentialAnswer = apps.get_model("scheme", "SchemeAccountCredentialAnswer")
    SchemeAccountEntry = apps.get_model("ubiquity", "SchemeAccountEntry")

    task_count = 0
    sql_offset = 0
    sql_limit = TASK_SIZE
    pks_to_process = True
    while pks_to_process:
        task_id = str(uuid4())
        for attempt in range(3):
            try:
                pks_to_process = list(
                    SchemeAccountEntry.objects.all().order_by("id")[sql_offset:sql_limit].values_list("id", flat=True)
                )
                break
            except OperationalError:
                logging.warning(f"Database connection failed!, retrying {2 - attempt} more times...")
                if attempt == 2:
                    raise
                sleep(0.2)

        if pks_to_process:
            task_count += 1
            sql_offset += TASK_SIZE
            sql_limit += TASK_SIZE
            retry_redis("set", task_id)
            retry_celery(task_id, pks_to_process)

    if task_count:
        logging.warning(f"Finished creating {task_count} async tasks, waiting till completion...")
        wait_for_tasks_to_finish()
    cleanup_answers_table(SchemeAccountCredentialAnswer)


def depopulate_answers(apps, *args):
    SchemeAccountCredentialAnswer = apps.get_model("scheme", "SchemeAccountCredentialAnswer")

    old_answers = SchemeAccountCredentialAnswer.objects.distinct("scheme_account_id", "question_id").values()
    bulk_answers = []
    for answer in old_answers:
        saca = SchemeAccountCredentialAnswer(
            scheme_account_id=answer.get("scheme_account_id"),
            question_id=answer.get("question_id"),
            answer=answer.get("answer"),
        )
        bulk_answers.append(saca)

    ## now clean up the answers table - remove all entries WITH scheme_account_entry
    SchemeAccountCredentialAnswer.objects.filter(scheme_account_entry__isnull=False).delete()

    ## now save the updated data
    SchemeAccountCredentialAnswer.objects.bulk_create(bulk_answers)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("ubiquity", "0015_schemeaccountentry_link_status"),
        ("scheme", "0108_alter_schemeaccount_status_and_more"),
    ]

    operations = [
        # remove old constraint
        migrations.AlterUniqueTogether(
            name="schemeaccountcredentialanswer",
            unique_together=set(),
        ),
        # create the new entry id field as a FK
        migrations.AddField(
            model_name="schemeaccountcredentialanswer",
            name="scheme_account_entry",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.CASCADE, to="ubiquity.schemeaccountentry"
            ),
        ),
        # this new field is a constraint
        migrations.AlterUniqueTogether(
            name="schemeaccountcredentialanswer",
            unique_together={("scheme_account_entry", "question")},
        ),
        migrations.AlterField(
            model_name="schemeaccountcredentialanswer",
            name="scheme_account",
            field=models.ForeignKey(
                blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to="scheme.SchemeAccount"
            ),
        ),
        migrations.AddField(
            model_name="schemeaccount",
            name="merchant_identifier",
            field=models.CharField(blank=True, db_index=True, default="", max_length=250),
        ),
        migrations.RenameField(
            model_name="schemeaccount",
            old_name="main_answer",
            new_name="alt_main_answer",
        ),
        # data population
        migrations.RunPython(populate_answers, reverse_code=depopulate_answers),
    ]
